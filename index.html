<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Video Player Pro</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#0a0a0a;color:#fff;min-height:100vh}
.hdr{background:linear-gradient(135deg,#1a1a2e,#16213e);padding:18px 24px;box-shadow:0 2px 20px rgba(0,0,0,.5)}
.hdr-in{max-width:1400px;margin:0 auto;display:flex;align-items:center;justify-content:space-between}
.logo{font-size:26px;font-weight:700;background:linear-gradient(135deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.sec-dot{background:rgba(76,175,80,.2);color:#4caf50;padding:5px 14px;border-radius:20px;font-size:12px;font-weight:600}
.wrap{max-width:1400px;margin:0 auto;padding:36px 20px}
.card{background:linear-gradient(135deg,#1a1a2e,#16213e);border-radius:18px;padding:36px;margin-bottom:28px;box-shadow:0 8px 32px rgba(0,0,0,.3)}
.card-title{font-size:22px;font-weight:700;margin-bottom:18px;background:linear-gradient(135deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
input[type=url]{width:100%;padding:15px 18px;background:rgba(255,255,255,.05);border:2px solid rgba(255,255,255,.1);border-radius:11px;color:#fff;font-size:15px;margin-bottom:18px;transition:border-color .2s}
input:focus{outline:none;border-color:#667eea}
input::placeholder{color:rgba(255,255,255,.35)}
.btn{padding:15px 40px;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;border:none;border-radius:11px;font-size:15px;font-weight:600;cursor:pointer;transition:transform .15s,opacity .15s}
.btn:hover:not(:disabled){transform:translateY(-2px)}
.btn:disabled{opacity:.5;cursor:not-allowed}
.sbadge{display:inline-block;margin-top:13px;background:rgba(76,175,80,.12);color:#4caf50;border:1px solid rgba(76,175,80,.28);padding:6px 14px;border-radius:7px;font-size:12px}
.err{background:rgba(244,67,54,.14);border:1px solid rgba(244,67,54,.3);color:#f44336;padding:13px 16px;border-radius:10px;margin-top:14px;display:none;line-height:1.55}

/* player */
#vSec{display:none}
#vSec.on{display:block}
.ph{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}
.ptitle{font-size:20px;font-weight:700}
.cbtn{padding:8px 18px;background:rgba(255,59,48,.18);color:#ff3b30;border:1px solid rgba(255,59,48,.25);border-radius:9px;cursor:pointer;font-weight:600;font-size:13px}
.cbtn:hover{background:rgba(255,59,48,.3)}
.pwrap{position:relative;padding-bottom:56.25%;height:0;background:#000;border-radius:14px;overflow:hidden}
video,iframe{position:absolute;inset:0;width:100%;height:100%;border:none}
.ov{position:absolute;inset:0;z-index:10;pointer-events:none}

/* buffer progress */
.bwrap{margin-top:10px;height:5px;background:rgba(255,255,255,.08);border-radius:4px;overflow:hidden}
.bbar{height:100%;width:0;background:linear-gradient(90deg,#667eea,#764ba2);border-radius:4px;transition:width .4s}
.blbl{font-size:11px;color:rgba(255,255,255,.35);margin-top:5px;text-align:right}

/* spinner overlay on video while buffering */
.spin-ov{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:20;transition:opacity .3s}
.spin-ov.hide{opacity:0;pointer-events:none}
.spin{width:48px;height:48px;border:3px solid rgba(255,255,255,.15);border-top-color:#667eea;border-radius:50%;animation:sp 1s linear infinite}
@keyframes sp{to{transform:rotate(360deg)}}

#loadSec{display:none;text-align:center;padding:56px;color:rgba(255,255,255,.5)}
.lspin{width:48px;height:48px;border:3px solid rgba(255,255,255,.1);border-top-color:#667eea;border-radius:50%;animation:sp 1s linear infinite;margin:0 auto 16px}

*{-webkit-user-select:none;-moz-user-select:none;user-select:none}
input[type=url]{-webkit-user-select:text;-moz-user-select:text;user-select:text}
video,img,iframe{-webkit-user-drag:none;user-drag:none}
@media(max-width:600px){.card{padding:20px}.logo{font-size:20px}}
</style>
</head>
<body>

<div class="hdr">
  <div class="hdr-in">
    <div class="logo">ğŸ¬ Video Player Pro</div>
    <div class="sec-dot">ğŸ”’ Protected</div>
  </div>
</div>

<div class="wrap">

  <div class="card">
    <div class="card-title">Load Secure Video</div>
    <input type="url" id="urlIn" placeholder="Paste Platform B video URLâ€¦ https://platform-bâ€¦/video/abc123">
    <button class="btn" id="loadBtn">â–¶ Load Video</button>
    <div class="sbadge">ğŸ›¡ Blob URL â€” IDM cannot detect or intercept Â· Token in header only</div>
    <div class="err" id="errBox"></div>
  </div>

  <div id="loadSec">
    <div class="lspin"></div>
    <p>Connectingâ€¦</p>
  </div>

  <div id="vSec" class="card">
    <div class="ph">
      <div class="ptitle">Now Playing</div>
      <button class="cbtn" id="closeBtn">âœ• Close</button>
    </div>
    <div class="pwrap">
      <video id="vid" controls playsinline preload="auto"
             controlsList="nodownload nofullscreen noremoteplayback"
             disablePictureInPicture oncontextmenu="return false;"></video>
      <iframe id="ifr" allowfullscreen allow="autoplay" oncontextmenu="return false;"></iframe>
      <div class="ov" oncontextmenu="return false;"></div>
      <div class="spin-ov" id="spinOv"><div class="spin"></div></div>
    </div>
    <div class="bwrap" id="bWrap" style="display:none"><div class="bbar" id="bBar"></div></div>
    <div class="blbl" id="bLbl"></div>
  </div>

</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SEC = '84418779257393762955868022673598';

// Buffer config tuned for a 1-hour video at ~2â€“4 Mbps â‰ˆ ~900MBâ€“1.8GB
// Strategy: keep 90s ahead, evict 60s behind, seek by re-fetching from new position
const CFG = {
  SEGMENT_BYTES:   4 * 1024 * 1024,  // 4MB per fetch â€” enough for ~8â€“16s of video
  AHEAD_TARGET:    90,                 // buffer 90s ahead of playhead
  AHEAD_MAX:       120,                // pause fetching at 2 min ahead
  AHEAD_RESUME:    20,                 // resume when ahead drops below 20s
  INITIAL_PLAY_S:  5,                  // start playback after 5s buffered
  EVICT_BEHIND_S:  60,                 // keep 60s behind playhead (for back-seek)
  SEEK_DEBOUNCE:   300,                // ms to wait after seek before fetching
  FETCH_TIMEOUT:   20000,              // 20s fetch timeout
  MAX_RETRIES:     3,                  // retry failed fetches
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let vid        = null;
let _ms        = null;   // MediaSource
let _sb        = null;   // SourceBuffer
let _stopped   = false;
let _token     = null;   // session token
let _endpoint  = null;   // stream endpoint URL
let _totalSize = 0;      // total file bytes
let _fetchedTo = 0;      // furthest byte we've appended
let _pump      = false;  // pump running?
let _seekTimer = null;
let _retries   = 0;
let _playStarted = false;
let _sbQueue   = [];     // pending SourceBuffer operations (only one at a time)
let _sbBusy    = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const norm  = u => u.replace(/([^:])\/\/+/g,'$1/');
const sleep = ms => new Promise(r => setTimeout(r, ms));

function showErr(msg) {
  const e = document.getElementById('errBox');
  e.innerHTML = 'âŒ ' + msg;
  e.style.display = 'block';
  setTimeout(() => { e.style.display = 'none'; }, 9000);
}

function setSpinner(on) {
  const s = document.getElementById('spinOv');
  if (s) s.classList.toggle('hide', !on);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUFFER INSPECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function bufferedAhead() {
  if (!vid || !vid.buffered || !vid.buffered.length) return 0;
  const ct = vid.currentTime;
  for (let i = 0; i < vid.buffered.length; i++) {
    if (vid.buffered.start(i) <= ct + 0.5 && vid.buffered.end(i) > ct)
      return vid.buffered.end(i) - ct;
  }
  return 0;
}

function isTimeInBuffer(t) {
  if (!vid || !vid.buffered) return false;
  for (let i = 0; i < vid.buffered.length; i++)
    if (vid.buffered.start(i) <= t + 0.25 && vid.buffered.end(i) >= t + 1) return true;
  return false;
}

function updateUI() {
  const bar = document.getElementById('bBar');
  const lbl = document.getElementById('bLbl');
  if (!bar || !_totalSize) return;
  const pct = Math.min(100, Math.round((_fetchedTo / _totalSize) * 100));
  bar.style.width = pct + '%';
  const ahead = bufferedAhead();
  lbl.textContent = _fetchedTo >= _totalSize
    ? 'Fully loaded âœ“'
    : `Loaded ${pct}% Â· ${Math.round(ahead)}s ahead`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SOURCEBUFFER QUEUE â€” serialises all append/remove operations
//  SourceBuffer allows only ONE operation at a time. Queuing prevents
//  "InvalidStateError: An attempt was made to use an object that is not,
//   or is no longer, usable" errors.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function sbOp(fn) {
  return new Promise((resolve, reject) => {
    _sbQueue.push({ fn, resolve, reject });
    drainSBQueue();
  });
}

function drainSBQueue() {
  if (_sbBusy || !_sbQueue.length || !_sb || !_ms || _ms.readyState !== 'open') return;
  if (_sb.updating) return; // will be called again on updateend
  const { fn, resolve, reject } = _sbQueue.shift();
  _sbBusy = true;
  const onEnd = () => { _sbBusy = false; resolve(); drainSBQueue(); };
  const onErr = (e) => { _sbBusy = false; reject(e); drainSBQueue(); };
  _sb.addEventListener('updateend', onEnd,  { once: true });
  _sb.addEventListener('error',     onErr, { once: true });
  try { fn(); } catch (e) { _sb.removeEventListener('updateend', onEnd); onErr(e); }
}

async function sbAppend(buf) {
  if (_stopped || !_sb || !_ms || _ms.readyState !== 'open') return false;
  try {
    await sbOp(() => _sb.appendBuffer(buf));
    return true;
  } catch (e) {
    if (e.name === 'QuotaExceededError') {
      await sbEvict(true); // force evict more aggressively
      try {
        await sbOp(() => _sb.appendBuffer(buf));
        return true;
      } catch (_) { return false; }
    }
    return false;
  }
}

async function sbEvict(aggressive = false) {
  if (!_sb || !vid || !_ms || _ms.readyState !== 'open') return;
  const ct     = vid.currentTime;
  const behind = aggressive ? Math.max(0, ct - 10) : Math.max(0, ct - CFG.EVICT_BEHIND_S);
  if (behind <= 0) return;
  try {
    await sbOp(() => _sb.remove(0, behind));
  } catch (_) {}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BYTE â†’ TIME MAPPING
//  We estimate which byte offset corresponds to a given second by
//  assuming constant bitrate (good enough for seeking purposes).
//  After seek, we fetch from that estimate and let the decoder correct.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function timeToByteOffset(seconds) {
  if (!vid || !vid.duration || !_totalSize) return 0;
  const fraction = Math.max(0, Math.min(1, seconds / vid.duration));
  // Align to 4KB boundary for better cache behaviour
  return Math.floor((fraction * _totalSize) / 4096) * 4096;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FETCH ONE SEGMENT
//  Fetches CFG.SEGMENT_BYTES bytes starting at `startByte`.
//  Returns { buf, bytesRead, eof }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchSegment(startByte) {
  const endByte = startByte + CFG.SEGMENT_BYTES - 1;
  const ctrl    = new AbortController();
  const timer   = setTimeout(() => ctrl.abort(), CFG.FETCH_TIMEOUT);
  try {
    const res = await fetch(_endpoint, {
      headers: {
        'X-Session-Token': _token,
        'Range':           `bytes=${startByte}-${endByte}`,
        'Origin':          location.origin,
      },
      signal: ctrl.signal,
    });
    clearTimeout(timer);

    if (res.status === 416) return { buf: null, bytesRead: 0, eof: true };  // past end
    if (!res.ok && res.status !== 206) throw new Error('HTTP ' + res.status);

    // Extract total file size from Content-Range header: bytes X-Y/TOTAL
    const cr = res.headers.get('content-range') || '';
    const totalMatch = cr.match(/\/(\d+)$/);
    if (totalMatch) _totalSize = parseInt(totalMatch[1], 10);

    const buf = await res.arrayBuffer();
    const eof = _totalSize > 0 && startByte + buf.byteLength >= _totalSize;
    return { buf, bytesRead: buf.byteLength, eof };
  } catch (e) {
    clearTimeout(timer);
    throw e;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PUMP â€” the main buffering loop
//  Runs continuously, fetching segments ahead of playhead.
//  Pauses when AHEAD_MAX is reached, resumes when it drops.
//  On seek: aborts, resets _fetchedTo, restarts from new position.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function startPump(startByte = 0) {
  if (_pump) return;
  _pump   = true;
  _retries = 0;
  let pos  = startByte;

  while (!_stopped) {
    // â”€â”€ 1. Check buffer health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const ahead = bufferedAhead();

    if (pos >= _totalSize && _totalSize > 0) {
      // All bytes fetched â€” signal end of stream
      if (_ms && _ms.readyState === 'open') {
        try {
          if (!_sb.updating) _ms.endOfStream();
        } catch (_) {}
      }
      updateUI();
      break;
    }

    if (_playStarted && ahead >= CFG.AHEAD_MAX) {
      // Buffer is healthy â€” pause and wait for it to drain
      _pump = false;
      const check = setInterval(() => {
        if (_stopped) { clearInterval(check); return; }
        if (bufferedAhead() < CFG.AHEAD_RESUME) {
          clearInterval(check);
          pos = timeToByteOffset(vid.currentTime + bufferedAhead() - 1);
          // Clamp to what we already fetched in case of overlap
          pos = Math.max(pos, 0);
          startPump(pos);
        }
      }, 1000);
      return;
    }

    // â”€â”€ 2. Fetch next segment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let seg;
    try {
      seg = await fetchSegment(pos);
      _retries = 0;
    } catch (e) {
      _retries++;
      if (_retries > CFG.MAX_RETRIES) {
        // Give up â€” show error, let user retry by seeking
        _pump = false;
        updateUI();
        return;
      }
      await sleep(Math.min(500 * _retries, 3000));
      continue;
    }

    // â”€â”€ 3. Append to SourceBuffer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (seg.buf && seg.buf.byteLength > 0) {
      // Evict old data to free memory (keep 60s behind playhead)
      if (pos % (CFG.SEGMENT_BYTES * 10) === 0) await sbEvict();

      const ok = await sbAppend(seg.buf);
      if (!ok) {
        // Append failed â€” try evicting and continue
        await sbEvict(true);
        continue;
      }
      pos += seg.bytesRead;
      _fetchedTo = Math.max(_fetchedTo, pos);

      // â”€â”€ 4. Start playback once initial buffer is ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (!_playStarted && bufferedAhead() >= CFG.INITIAL_PLAY_S) {
        _playStarted = true;
        setSpinner(false);
        vid.play().catch(() => {});
      }

      updateUI();
    }

    if (seg.eof) {
      if (_ms && _ms.readyState === 'open') {
        try { if (!_sb.updating) _ms.endOfStream(); } catch (_) {}
      }
      updateUI();
      break;
    }
  }

  _pump = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SEEK HANDLER
//  When user seeks: flush the SourceBuffer, restart fetch from new position
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleSeek() {
  if (!vid || !_sb || !_ms) return;
  clearTimeout(_seekTimer);
  _seekTimer = setTimeout(async () => {
    const seekTo = vid.currentTime;

    // Is the seek destination already in the buffer?
    if (isTimeInBuffer(seekTo)) return; // nothing to do

    setSpinner(true);

    // Stop current pump
    _pump = false;
    await sleep(50); // let any in-flight fetch finish

    // Flush the SourceBuffer â€” clear everything except a small window around seekTo
    if (_ms && _ms.readyState === 'open' && _sb && !_sb.updating) {
      try {
        // Keep 5s before seek point (for brief back-seeks) and remove rest
        const keepFrom = Math.max(0, seekTo - 5);
        const keepTo   = seekTo + 2; // keep a little ahead to avoid stutter
        if (keepFrom > 0) {
          await sbOp(() => _sb.remove(0, keepFrom));
        }
        // Remove far ahead (stale data past the seek point we're jumping to)
        if (keepTo < seekTo + 5 && _totalSize > 0) {
          const totalDuration = vid.duration || 99999;
          if (keepTo < totalDuration - 1) {
            try { await sbOp(() => _sb.remove(keepTo, totalDuration)); } catch (_) {}
          }
        }
      } catch (_) {}
    }

    // Recalculate byte offset for seek position
    const bytePos = timeToByteOffset(Math.max(0, seekTo - 2)); // 2s before for context
    _fetchedTo    = bytePos;

    // Restart pump from new position
    startPump(bytePos);
  }, CFG.SEEK_DEBOUNCE);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN: START STREAM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function startStream(endpoint, token) {
  _endpoint    = endpoint;
  _token       = token;
  _stopped     = false;
  _fetchedTo   = 0;
  _totalSize   = 0;
  _playStarted = false;
  _pump        = false;
  _sbQueue     = [];
  _sbBusy      = false;

  document.getElementById('bWrap').style.display = 'block';
  setSpinner(true);

  // â”€â”€ Set up MediaSource â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (_ms) { try { _ms.endOfStream(); } catch (_) {} }
  _ms = new MediaSource();

  // Give <video> a blob: URL â€” IDM has NOTHING to intercept
  vid.src = URL.createObjectURL(_ms);

  await new Promise((res, rej) => {
    _ms.addEventListener('sourceopen', res, { once: true });
    _ms.addEventListener('error',      rej, { once: true });
  });

  // Pick the best supported MIME type
  const MIME_CANDIDATES = [
    'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
    'video/mp4; codecs="avc1.640028, mp4a.40.2"',
    'video/mp4; codecs="avc1.64001F, mp4a.40.2"',
    'video/mp4',
  ];
  const mimeType = MIME_CANDIDATES.find(m => MediaSource.isTypeSupported(m));
  if (!mimeType) throw new Error('Your browser does not support MP4 streaming. Please use Chrome or Edge.');

  _sb = _ms.addSourceBuffer(mimeType);

  // CRITICAL: Use 'segments' mode (not 'sequence').
  // In segments mode, the SourceBuffer respects the timestamps embedded in
  // the MP4 fragments, which means seeking works by time not by append order.
  // This is what makes forward/backward seeking instant and correct.
  _sb.mode = 'segments';

  // Wire SourceBuffer events to drain the queue
  _sb.addEventListener('updateend', drainSBQueue);

  // â”€â”€ Wire video events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  vid.addEventListener('seeking',    handleSeek);
  vid.addEventListener('timeupdate', updateUI);
  vid.addEventListener('waiting',    () => {
    setSpinner(true);
    if (!_pump && !_stopped) startPump(timeToByteOffset(Math.max(0, vid.currentTime - 1)));
  });
  vid.addEventListener('playing',    () => setSpinner(false));
  vid.addEventListener('canplay',    () => setSpinner(false));

  // â”€â”€ Start filling the buffer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  startPump(0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOAD VIDEO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadVideo() {
  const url  = document.getElementById('urlIn').value.trim();
  const btn  = document.getElementById('loadBtn');
  const load = document.getElementById('loadSec');
  const vSec = document.getElementById('vSec');
  vid = document.getElementById('vid');
  const ifr = document.getElementById('ifr');

  document.getElementById('errBox').style.display = 'none';

  if (!url || !url.includes('/video/')) {
    showErr('Invalid URL â€” must contain /video/'); return;
  }

  vSec.classList.remove('on');
  load.style.display = 'block';
  btn.disabled = true;

  try {
    const m = url.match(/\/video\/([^/?#]+)/);
    if (!m) throw new Error('Cannot extract video ID from URL');
    const videoId = m[1];
    const base    = url.slice(0, url.indexOf('/video/'));

    const res = await fetch(norm(base + '/api/video/' + videoId), {
      headers: { 'X-Security-String': SEC, 'Accept': 'application/json' }
    });
    if (res.status === 403) throw new Error('Access denied â€” wrong security key');
    if (res.status === 404) throw new Error('Video not found');
    if (!res.ok)            throw new Error('Server error: ' + res.status);

    const data = await res.json();
    if (!data.success) throw new Error(data.message || 'Load failed');

    load.style.display = 'none';
    vSec.classList.add('on');
    btn.disabled = false;

    if (data.type === 'embed') {
      ifr.src = norm(data.proxyUrl) + '?key=' + encodeURIComponent(SEC);
      ifr.style.display = 'block';
      vid.style.display = 'none';
      document.getElementById('bWrap').style.display = 'none';
      document.getElementById('spinOv').classList.add('hide');
    } else {
      vid.style.display = 'block';
      ifr.style.display = 'none';
      if (!data.sessionToken)    throw new Error('No session token â€” redeploy Platform B');
      if (!data.streamEndpoint)  throw new Error('No stream endpoint â€” redeploy Platform B');

      if (typeof MediaSource === 'undefined') {
        throw new Error('MediaSource API not supported in this browser. Please use Chrome or Edge.');
      }

      await startStream(data.streamEndpoint, data.sessionToken);
    }
  } catch (e) {
    load.style.display = 'none';
    btn.disabled = false;
    showErr(e.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CLOSE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function closeVideo() {
  _stopped = true;
  _pump    = false;
  clearTimeout(_seekTimer);
  document.getElementById('vSec').classList.remove('on');
  document.getElementById('bWrap').style.display = 'none';
  document.getElementById('bLbl').textContent    = '';
  document.getElementById('spinOv').classList.add('hide');
  if (_ms)  { try { _ms.endOfStream(); } catch (_) {} _ms = null; _sb = null; _sbQueue = []; }
  if (vid)  { vid.pause(); vid.removeAttribute('src'); vid.load(); }
  const ifr = document.getElementById('ifr'); if (ifr) ifr.src = '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EVENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('loadBtn') .addEventListener('click',    loadVideo);
document.getElementById('closeBtn').addEventListener('click',    closeVideo);
document.getElementById('urlIn')   .addEventListener('keypress', e => { if (e.key === 'Enter') loadVideo(); });

// Auto-hide error
new MutationObserver(() => {
  const e = document.getElementById('errBox');
  if (e.style.display === 'block') setTimeout(() => { e.style.display = 'none'; }, 9000);
}).observe(document.getElementById('errBox'), { attributes: true, attributeFilter: ['style'] });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANTI-DOWNLOAD / ANTI-RECORD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('contextmenu', e => { e.preventDefault(); return false; });

document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if ((e.ctrlKey||e.metaKey) && ['s','u','p','i','j','c'].includes(k))   { e.preventDefault(); return false; }
  if ((e.ctrlKey||e.metaKey) && e.shiftKey && ['i','j','c'].includes(k)) { e.preventDefault(); return false; }
  if (['f12','printscreen'].includes(k))                                  { e.preventDefault(); return false; }
  if (e.metaKey && k === 'g')                                             { e.preventDefault(); return false; }
  if (e.metaKey && e.altKey && k === 'r')                                 { e.preventDefault(); return false; }
});

document.addEventListener('dragstart', e => { e.preventDefault(); return false; });

document.addEventListener('visibilitychange', () => {
  const v = document.getElementById('vid');
  if (v && document.hidden) v.pause();
});

// Block screen capture APIs
if (navigator.mediaDevices) {
  try { Object.defineProperty(navigator.mediaDevices,'getDisplayMedia',{configurable:false,writable:false,value:()=>Promise.reject(new DOMException('Not allowed','NotAllowedError'))}); } catch(_){}
  try {
    const _g = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    Object.defineProperty(navigator.mediaDevices,'getUserMedia',{configurable:false,writable:false,value:c=>c?.video?Promise.reject(new DOMException('Not allowed','NotAllowedError')):_g(c)});
  } catch(_){}
}
try { Object.defineProperty(window,'MediaRecorder',{configurable:false,writable:false,value:function(){throw new DOMException('Disabled','NotSupportedError');}}); } catch(_){}

// DevTools detection
(function(){
  let open=false;
  setInterval(()=>{
    const isOpen=window.outerWidth-window.innerWidth>160||window.outerHeight-window.innerHeight>160;
    const v=document.getElementById('vid'),f=document.getElementById('ifr');
    if(isOpen&&!open){open=true;if(v){v.pause();v.style.visibility='hidden';}if(f)f.style.visibility='hidden';}
    else if(!isOpen&&open){open=false;if(v)v.style.visibility='visible';if(f)f.style.visibility='visible';}
  },800);
})();
</script>
</body>
</html>
